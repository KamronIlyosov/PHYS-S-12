<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="../style.css" rel="stylesheet">

<nav class="navbar navbar-expand-sm navbar-dark" style=" color: #EEE7E8;">
  <div style="align-items: center; justify-content: center;" class="container-fluid">
    <div class="flexrow">
      <h2 class="nav-title">PS70 Fall 2024</h2>
    </div>
    <div class="navbar-nav">
      <h4><a class="nav-link" href="../index.html">Home</a></h4>
      <h4><a class="nav-link" href="../about.html">About</a></h4>
    </div>
  </div>
</nav>

<!-- Main Content -->
<div class="container mt-5">
<br>
  </style>
</head>
<body>
  <header>
    <h1>Regenerative Leg Device Project</h1>
    <h4>A wearable device that generates electricity from walking</h4>
  </header>
<br>
  <section>
    <h2>Project Overview</h2>
    <h4>For this weeks project I decided to challenge the most intimidating aspect of my final prject, so I made a fully functional small scale version of my final project, a wearable charging device powered by walking. And on top of that added new features such as steps taken, calories burned, and how much power you are generating (in volts) displayed on an OLED screen. I also researched ways to solve issues I had with my previous prototype, such as how the power would flow in 2 different polarities depending on the direction the motor spun.</h4>
    <br>
  </section>
  <br>
<div style="display: flex; align-items: center;">
  <video src="steps.mp4" width="260" height="440" object-fit="fill" controls></video>
  <img src="picture.jpg" width="260" height="440" alt="Vertical Image">
  <video src="all.mp4" width="260" height="440" controls></video>
</div>
<br>

  <section>
    <h2>Steps Taken</h2>
    <div class="step">
      <strong>Step 1: Research</strong>
      <h4>Researched energy harvesting from using mechanical to electrical conversion via small motors, I found that my previous prototype in "Week 5: 3D design" couldnt keep electricity flowing in one steady polarity and when the rod wpould go back and forth it woul only light 2 LED's at a time due to changes in polarity.</h4>
      <img src="motor.jpg" width="750" height="350" alt="Vertical Image">
    </div>
    <br>
    <div class="step">
      <strong>Step 2: 3D printing new rod for the motor shaft</strong>
      <h4> In my last version of the prototype I used a metal rod as the part which is supposed to strap on your calf, however it had fitment issues and I wanted something that fits onto the shaft perfectly.</h4>
      <br>
    </div>
    <div class="step">
      <strong>Step 4: Voltage Polarity Fix</strong>
      <h4>Installed a BR86D bridge rectifier so voltage output remains positive regardless of spin direction, to do this I <h4>I connected the two AC (~) inputs of the BR86D to the two terminals of the DC motor. This allows the bridge rectifier to convert the AC voltage generated by the motor into DC.</h4>

      <img src="bridge.jpg" alt="Rectifier wiring">
    </div>
    <div class="step">
    <div class="step">
      <br>
  <strong>Step 5: Voltage Reading</strong>
  <h4>After converting AC to DC using the BR86D bridge rectifier, I connected a 100µF capacitor across the output to smooth the signal. I then used a voltage divider made from two resistors to scale down the voltage to safe levels before connecting it to analog pin A0. This allows the microcontroller to safely measure how much voltage is generated while walking.</h4>
  <div style="display: flex; gap: 10px; align-items: flex-start;">
  <img src="circuit3.jpg" width="260" height="440" alt="Vertical Image">
  <video src="volts.mp4" width="260" height="440" controls></video>
</div>
<br>

<div class="step">
  <strong>Step 6: Step Detection</strong>
  <h4>I mounted a DRV5055A Hall effect sensor near the "knee joint", with a small magnet on the 3D printed rod so that it passes by the sensor each time I simulate a step. The microcontroller reads analog values from the sensor on pin A1 and detects magnetic pulses to count full steps based on a two pulse system.</h4>
  <img src="hallsensor.jpg" width="260" height="440" alt="Vertical Image">
</div>
<br>
<div class="step">
  <strong>Step 7: Improved Rod Version</strong>
  <h4>I noticed that my newly printed rod was too bulky for my liking and I didnt like how the magnet was indented forward, as I just glued it on. To fix this issue, I made an improved and thinner version of the rod, with a perfect extrusion to fit the magnet flushly.</h4>
  <div style="display: flex;">
  <div style="display: flex; gap: 10px;">
  <img src="before.jpg" alt="Hall sensor mounted" width="260" height="440">
  <img src="CAD.jpg" alt="Hall sensor mounted" width="260" height="440">
  <img src="magnet.jpg" alt="Hall sensor mounted" width="260" height="440">
</div>

</div>
<br>
<div class="step">
  <strong>Step 8: Calories Estimation</strong>
  <br>
  <h4>To provide a rough estimate of calories burned, I researched the calories burned per step for the average person, and programmed the microcontroller to calculate this using a constant multiplier of 0.05 per step. This value is updated in real time on the OLED screen after every detected step.</h4>
  <img src="calories.jpg" alt="Hall sensor mounted" width="260" height="440">
  <br>
  <br>
  <div style="background-color: #ffffff; color: #000000; padding: 15px; border: 1px solid #000; border-radius: 5px;">
 <pre style="background-color: white; color: black; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; font-family: monospace;">
 if (pulseCount == 2) {
      stepCount++;
      caloriesBurned = stepCount * 0.05;
      pulseCount = 0;
    }
</pre>
</div>
<br>
<div class="step">
  <strong>Step 9: User Interface</strong>
  <h4>Three push buttons were wired to digital pins D2, D3, and D6. I implemented debouncing in the code to prevent accidental multiple readings. Each button press allows the user to switch between three modes: Step Count, Calories Burned, and Voltage Reading. </h4>
  <img src="images/step8_buttons.jpg" alt="Button wiring">
</div>
<br>
<div class="step">
  <strong>Step 10: Display Integration</strong>
  <h4>An OLED screen was connected to the microcontroller via the I2C interface. The screen updates depending on inputs, displaying either the step count, estimated calories, or voltage being generated by the motor. </h4>
  <img src="images/step9_oled.jpg" alt="OLED display test">
</div>
<br>
<div class="step">
  <strong>Step 10: Final Testing</strong>
  <h4>I conducted a final test of my prototype ensuring all sensors and wiring worked as expected. After turning the rod back and forth replicating the movement of walking, I confirmed that the hall sensor was accurately detecting steps, the motor was generating voltage, and the OLED displayed all outputs correctly in real time. I also found that the voltage ranged from 0.69 to about 4.08 at its peak.</h4>
    <img src=".jpg" alt="Hall sensor mounted" width="260" height="440">
     <img src=".jpg" alt="Hall sensor mounted" width="260" height="440">
  </div>

<br>
  <section>
    <h2>Main Features</h2>
    <ul>
      <li>Counts steps using a Hall sensor and a magnet</li>
      <li>Estimates calories burned (based on steps)</li>
      <li>Displays generated voltage from the motor</li>
      <li>OLED screen with 3 user-selectable display modes</li>
    </ul>
  </section>

  </section>
    </ul>
  </section>

  </section>

<h2>Hardware Used</h2>
<div class="hardware-container">
  <ul>
    <li>OLED display</li>
    <li>DRV5055A Hall effect sensor</li>
    <li>DC motor (generator)</li>
    <li>BR86D bridge rectifier</li>
    <li>3 push buttons</li>
    <li>Microcontroller (XIAO ESP32C3)</li>
    <li>Resistors, wires, and a small breadboard</li>
  </ul>

<img src="materials.jpg" alt="materials" width="360" height="440" style="transform: rotate(-90deg); margin-left: 100px;">

</div>

  </section>

  <section>
    <h2>Code Summary</h2>
<p>This Arduino code reads signals from a Hall sensor to detect magnetic pulses caused by a magnet passing by. I count two pulses as one step and then estimate calories burned by multiplying steps by 0.05. The code also reads the motor voltage using an analog pin and converts the raw value to volts. Using three buttons, the user can switch between showing steps, calories, or voltage on the OLED screen. To avoid button noise, I added a debounce delay so the mode only changes when the button press is stable. The display updates by clearing and showing the current value without extra text labels.</p>

<div style="background-color: #ffffff; color: #000000; padding: 15px; border: 1px solid #000; border-radius: 5px;">
 <pre style="background-color: white; color: black; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; font-family: monospace;">
#include Adafruit_GFX.h
#include Adafruit_SSD1306.h

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const int hallPin = A1;
const int motorVoltagePin = A0;
const int buttonStepPin = D2;
const int buttonCalPin = D3;
const int buttonPowerPin = D6;

const int rawThreshold = 2500;
int pulseCount = 0;
int stepCount = 0;
float caloriesBurned = 0;
bool magnetDetected = false;

int mode = 0;

unsigned long lastButtonTime = 0;
const unsigned long debounceDelay = 150;

void setup() {
  Serial.begin(9600);

  pinMode(buttonStepPin, INPUT_PULLUP);
  pinMode(buttonCalPin, INPUT_PULLUP);
  pinMode(buttonPowerPin, INPUT_PULLUP);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("OLED failed"));
    while (true);
  }

  display.clearDisplay();
  display.display();
}

void loop() {
  int rawValue = analogRead(hallPin);
  if (!magnetDetected && rawValue < rawThreshold) {
    magnetDetected = true;
    pulseCount++;
    if (pulseCount == 2) {
      stepCount++;
      caloriesBurned = stepCount * 0.05;
      pulseCount = 0;
    }
  }
  if (magnetDetected && rawValue > rawThreshold + 100) {
    magnetDetected = false;
  }

  unsigned long now = millis();
  if (now - lastButtonTime > debounceDelay) {
    if (digitalRead(buttonStepPin) == LOW) {
      mode = 0;
      lastButtonTime = now;
    } else if (digitalRead(buttonCalPin) == LOW) {
      mode = 1;
      lastButtonTime = now;
    } else if (digitalRead(buttonPowerPin) == LOW) {
      mode = 2;
      lastButtonTime = now;
    }
  }

  display.clearDisplay();

  if (mode == 0) {
    display.setCursor(0, 35);
    display.print(stepCount);
  } else if (mode == 1) {
    display.setCursor(0, 35);
    display.print(caloriesBurned, 1);
  } else if (mode == 2) {
    int raw = analogRead(motorVoltagePin);
    float volts = raw * (3.3 / 4095.0) * 2.0;
    display.setCursor(0, 35);
    display.print(volts, 2);
  }

  display.display();
}

</pre>

</div>


  <section>
    <h2>How It Works</h2>
    <ul>
      <li><strong>Steps:</strong> Every 2 low signals from the Hall sensor counts as 1 step.</li>
      <li><strong>Calories:</strong> Estimated as 0.05 calories per step.</li>
      <li><strong>Voltage:</strong> Measured from A0 using analogRead and scaled to estimate actual voltage.</li>
    </ul>
  </section>

  <section>
    <h2>Tips & Notes</h2>
    <ul>
      <li>Use a full-bridge rectifier (BR86D) so the motor produces positive voltage in both spin directions.</li>
      <li>You can smooth the voltage signal with a capacitor.</li>
      <li>Use pull up resistors or INPUT_PULLUP mode for buttons to avoid false triggers.</li>
    </ul>
  </section>

<h2>Ossiloscope Findings</h2>

<title>Oscilloscope Findings</title>
</head>
<body>

<h4>Looking at the signal using the oscilloscope</h4>
<p>The device runs on a steady clock. We see a repeating pattern, a rising slope and then a quick drop, showing a regular signal. The time intervals are 2.00 µs per division, showing 10.0 µs across the screen at 5X zoom. The frequency is 2.033 kHz, showing how fast the device is working.</p>
<img src="zoomedinwave.jpg" alt="Long view of oscilloscope waveform" height="250" width="350">

<h4>This view shows more of the signal cycles</h4>
<p>Here, the time scale is set to 40.0 µs with 4X zoom, showing more wave patterns. The frequency reads 2.026 kHz, close to the earlier value, confirming the steady timing of the signal.</p>
<img src="zoomedoutwave.jpg" alt="Short view of oscilloscope waveform" height="250" width="350">

<h4>Measuring voltage and time between peaks</h4>
<p>I used the cursor tools to measure. The time between peaks is 3.04 µs, and the voltage is 4 V peak to peak. The signal's frequency is about 1.99 kHz.</p>
<img src="peaktopeak.jpg" alt="Peak-to-peak measurement on oscilloscope" height="250" width="350">

<h4>Zoomed in to show the start of one wave</h4>
<p>This image shows the very beginning of one wave. I circled the part where the rising ramp starts.</p>
<img src="startofthewave.jpg" alt="Start of a waveform cycle" height="250" width="350">

<h4>Zoomed in to show the end of one wave</h4>
<p>This image shows where the wave ends. I circled the sharp drop that happens just before the next wave starts.</p>
<img src="end3.jpg" alt="End of a waveform cycle" height="250" width="350">

<h4>A strange detail I saw when zoomed in closely was a wobble like wave pattern at the complete bottom of the wave, but didnt manage to get a clear picture of it.</h4>

<h3>Final thoughts on the signal</h3>
<h4>From all of these views, it’s clear that the device is running with a steady clock, around 2 kHz. The waveform keeps repeating with a smooth rise and sharp drop.</h4>

</body>
</html>


</body>
</html>

  </footer>
</body>
</html>
